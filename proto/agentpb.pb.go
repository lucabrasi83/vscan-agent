// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/agentpb.proto

package agentpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// SSHGateway message represents an SSH Gateway settings to be used in order to scan devices
// located on a private network.
// This is an optional message
type SSHGateway struct {
	GatewayName       string `protobuf:"bytes,1,opt,name=gateway_name,json=gatewayName,proto3" json:"gateway_name,omitempty"`
	GatewayIp         string `protobuf:"bytes,2,opt,name=gateway_ip,json=gatewayIp,proto3" json:"gateway_ip,omitempty"`
	GatewayUsername   string `protobuf:"bytes,3,opt,name=gateway_username,json=gatewayUsername,proto3" json:"gateway_username,omitempty"`
	GatewayPassword   string `protobuf:"bytes,4,opt,name=gateway_password,json=gatewayPassword,proto3" json:"gateway_password,omitempty"`
	GatewayPrivateKey string `protobuf:"bytes,5,opt,name=gateway_private_key,json=gatewayPrivateKey,proto3" json:"gateway_private_key,omitempty"`
}

func (m *SSHGateway) Reset()         { *m = SSHGateway{} }
func (m *SSHGateway) String() string { return proto.CompactTextString(m) }
func (*SSHGateway) ProtoMessage()    {}
func (*SSHGateway) Descriptor() ([]byte, []int) {
	return fileDescriptor_agentpb_355d40ef13dbfd8b, []int{0}
}
func (m *SSHGateway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSHGateway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSHGateway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SSHGateway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHGateway.Merge(dst, src)
}
func (m *SSHGateway) XXX_Size() int {
	return m.Size()
}
func (m *SSHGateway) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHGateway.DiscardUnknown(m)
}

var xxx_messageInfo_SSHGateway proto.InternalMessageInfo

func (m *SSHGateway) GetGatewayName() string {
	if m != nil {
		return m.GatewayName
	}
	return ""
}

func (m *SSHGateway) GetGatewayIp() string {
	if m != nil {
		return m.GatewayIp
	}
	return ""
}

func (m *SSHGateway) GetGatewayUsername() string {
	if m != nil {
		return m.GatewayUsername
	}
	return ""
}

func (m *SSHGateway) GetGatewayPassword() string {
	if m != nil {
		return m.GatewayPassword
	}
	return ""
}

func (m *SSHGateway) GetGatewayPrivateKey() string {
	if m != nil {
		return m.GatewayPrivateKey
	}
	return ""
}

// UserDeviceCredentials represents the device credentials the VSCAN Agent must use to access the device.
type UserDeviceCredentials struct {
	CredentialsName         string `protobuf:"bytes,1,opt,name=credentials_name,json=credentialsName,proto3" json:"credentials_name,omitempty"`
	CredentialsDeviceVendor string `protobuf:"bytes,2,opt,name=credentials_device_vendor,json=credentialsDeviceVendor,proto3" json:"credentials_device_vendor,omitempty"`
	Username                string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
	Password                string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	IosEnablePassword       string `protobuf:"bytes,5,opt,name=ios_enable_password,json=iosEnablePassword,proto3" json:"ios_enable_password,omitempty"`
	PrivateKey              string `protobuf:"bytes,6,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
}

func (m *UserDeviceCredentials) Reset()         { *m = UserDeviceCredentials{} }
func (m *UserDeviceCredentials) String() string { return proto.CompactTextString(m) }
func (*UserDeviceCredentials) ProtoMessage()    {}
func (*UserDeviceCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_agentpb_355d40ef13dbfd8b, []int{1}
}
func (m *UserDeviceCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDeviceCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDeviceCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UserDeviceCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDeviceCredentials.Merge(dst, src)
}
func (m *UserDeviceCredentials) XXX_Size() int {
	return m.Size()
}
func (m *UserDeviceCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDeviceCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_UserDeviceCredentials proto.InternalMessageInfo

func (m *UserDeviceCredentials) GetCredentialsName() string {
	if m != nil {
		return m.CredentialsName
	}
	return ""
}

func (m *UserDeviceCredentials) GetCredentialsDeviceVendor() string {
	if m != nil {
		return m.CredentialsDeviceVendor
	}
	return ""
}

func (m *UserDeviceCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserDeviceCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserDeviceCredentials) GetIosEnablePassword() string {
	if m != nil {
		return m.IosEnablePassword
	}
	return ""
}

func (m *UserDeviceCredentials) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

// Device represents the device name / ip address pair a scan is requested for.
type Device struct {
	DeviceName string `protobuf:"bytes,1,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	IpAddress  string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_agentpb_355d40ef13dbfd8b, []int{2}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Device.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(dst, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *Device) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

// ScanRequest contains the protocol buffer message attributes required for VSCAN Agent to generate the scan job
// config and run the vulnerability assessment on the target device(s)
// If invalid arguments are sent, an INVALID_ARGUMENT GRPC error code will be sent back
// If the VSCAN Agent is not able to run the scan on any device (network connectivity issue, wrong credentials
// provided, ... ) a RESOURCE_EXHAUSTED GRPC error code will be returned
// It is expected for a Scan job not to take more than 15 minutes. Therefore, the client should Cancel the request
// and the server abort the scan job if no result is provided after 15 minutes.
type ScanRequest struct {
	JobId                 string                 `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Devices               []*Device              `protobuf:"bytes,2,rep,name=devices,proto3" json:"devices,omitempty"`
	SshGateway            *SSHGateway            `protobuf:"bytes,3,opt,name=ssh_gateway,json=sshGateway,proto3" json:"ssh_gateway,omitempty"`
	UserDeviceCredentials *UserDeviceCredentials `protobuf:"bytes,4,opt,name=user_device_credentials,json=userDeviceCredentials,proto3" json:"user_device_credentials,omitempty"`
	OvalSourceUrl         string                 `protobuf:"bytes,5,opt,name=oval_source_url,json=ovalSourceUrl,proto3" json:"oval_source_url,omitempty"`
}

func (m *ScanRequest) Reset()         { *m = ScanRequest{} }
func (m *ScanRequest) String() string { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()    {}
func (*ScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_agentpb_355d40ef13dbfd8b, []int{3}
}
func (m *ScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanRequest.Merge(dst, src)
}
func (m *ScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanRequest proto.InternalMessageInfo

func (m *ScanRequest) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *ScanRequest) GetDevices() []*Device {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *ScanRequest) GetSshGateway() *SSHGateway {
	if m != nil {
		return m.SshGateway
	}
	return nil
}

func (m *ScanRequest) GetUserDeviceCredentials() *UserDeviceCredentials {
	if m != nil {
		return m.UserDeviceCredentials
	}
	return nil
}

func (m *ScanRequest) GetOvalSourceUrl() string {
	if m != nil {
		return m.OvalSourceUrl
	}
	return ""
}

type ScanResultsResponse struct {
	ScanResultsJson []byte `protobuf:"bytes,1,opt,name=scan_results_json,json=scanResultsJson,proto3" json:"scan_results_json,omitempty"`
	VscanAgentName  string `protobuf:"bytes,2,opt,name=vscan_agent_name,json=vscanAgentName,proto3" json:"vscan_agent_name,omitempty"`
	DeviceName      string `protobuf:"bytes,3,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
}

func (m *ScanResultsResponse) Reset()         { *m = ScanResultsResponse{} }
func (m *ScanResultsResponse) String() string { return proto.CompactTextString(m) }
func (*ScanResultsResponse) ProtoMessage()    {}
func (*ScanResultsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_agentpb_355d40ef13dbfd8b, []int{4}
}
func (m *ScanResultsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanResultsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanResultsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ScanResultsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanResultsResponse.Merge(dst, src)
}
func (m *ScanResultsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanResultsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanResultsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanResultsResponse proto.InternalMessageInfo

func (m *ScanResultsResponse) GetScanResultsJson() []byte {
	if m != nil {
		return m.ScanResultsJson
	}
	return nil
}

func (m *ScanResultsResponse) GetVscanAgentName() string {
	if m != nil {
		return m.VscanAgentName
	}
	return ""
}

func (m *ScanResultsResponse) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func init() {
	proto.RegisterType((*SSHGateway)(nil), "agentpb.SSHGateway")
	proto.RegisterType((*UserDeviceCredentials)(nil), "agentpb.UserDeviceCredentials")
	proto.RegisterType((*Device)(nil), "agentpb.Device")
	proto.RegisterType((*ScanRequest)(nil), "agentpb.ScanRequest")
	proto.RegisterType((*ScanResultsResponse)(nil), "agentpb.ScanResultsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VscanAgentServiceClient is the client API for VscanAgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VscanAgentServiceClient interface {
	BuildScanConfig(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (VscanAgentService_BuildScanConfigClient, error)
}

type vscanAgentServiceClient struct {
	cc *grpc.ClientConn
}

func NewVscanAgentServiceClient(cc *grpc.ClientConn) VscanAgentServiceClient {
	return &vscanAgentServiceClient{cc}
}

func (c *vscanAgentServiceClient) BuildScanConfig(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (VscanAgentService_BuildScanConfigClient, error) {
	stream, err := c.cc.NewStream(ctx, &_VscanAgentService_serviceDesc.Streams[0], "/agentpb.VscanAgentService/BuildScanConfig", opts...)
	if err != nil {
		return nil, err
	}
	x := &vscanAgentServiceBuildScanConfigClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VscanAgentService_BuildScanConfigClient interface {
	Recv() (*ScanResultsResponse, error)
	grpc.ClientStream
}

type vscanAgentServiceBuildScanConfigClient struct {
	grpc.ClientStream
}

func (x *vscanAgentServiceBuildScanConfigClient) Recv() (*ScanResultsResponse, error) {
	m := new(ScanResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VscanAgentServiceServer is the server API for VscanAgentService service.
type VscanAgentServiceServer interface {
	BuildScanConfig(*ScanRequest, VscanAgentService_BuildScanConfigServer) error
}

func RegisterVscanAgentServiceServer(s *grpc.Server, srv VscanAgentServiceServer) {
	s.RegisterService(&_VscanAgentService_serviceDesc, srv)
}

func _VscanAgentService_BuildScanConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VscanAgentServiceServer).BuildScanConfig(m, &vscanAgentServiceBuildScanConfigServer{stream})
}

type VscanAgentService_BuildScanConfigServer interface {
	Send(*ScanResultsResponse) error
	grpc.ServerStream
}

type vscanAgentServiceBuildScanConfigServer struct {
	grpc.ServerStream
}

func (x *vscanAgentServiceBuildScanConfigServer) Send(m *ScanResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _VscanAgentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agentpb.VscanAgentService",
	HandlerType: (*VscanAgentServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BuildScanConfig",
			Handler:       _VscanAgentService_BuildScanConfig_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/agentpb.proto",
}

func (m *SSHGateway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSHGateway) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.GatewayName)))
		i += copy(dAtA[i:], m.GatewayName)
	}
	if len(m.GatewayIp) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.GatewayIp)))
		i += copy(dAtA[i:], m.GatewayIp)
	}
	if len(m.GatewayUsername) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.GatewayUsername)))
		i += copy(dAtA[i:], m.GatewayUsername)
	}
	if len(m.GatewayPassword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.GatewayPassword)))
		i += copy(dAtA[i:], m.GatewayPassword)
	}
	if len(m.GatewayPrivateKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.GatewayPrivateKey)))
		i += copy(dAtA[i:], m.GatewayPrivateKey)
	}
	return i, nil
}

func (m *UserDeviceCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDeviceCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CredentialsName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.CredentialsName)))
		i += copy(dAtA[i:], m.CredentialsName)
	}
	if len(m.CredentialsDeviceVendor) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.CredentialsDeviceVendor)))
		i += copy(dAtA[i:], m.CredentialsDeviceVendor)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.IosEnablePassword) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.IosEnablePassword)))
		i += copy(dAtA[i:], m.IosEnablePassword)
	}
	if len(m.PrivateKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.PrivateKey)))
		i += copy(dAtA[i:], m.PrivateKey)
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeviceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.DeviceName)))
		i += copy(dAtA[i:], m.DeviceName)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.JobId)))
		i += copy(dAtA[i:], m.JobId)
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAgentpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SshGateway != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(m.SshGateway.Size()))
		n1, err := m.SshGateway.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UserDeviceCredentials != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(m.UserDeviceCredentials.Size()))
		n2, err := m.UserDeviceCredentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.OvalSourceUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.OvalSourceUrl)))
		i += copy(dAtA[i:], m.OvalSourceUrl)
	}
	return i, nil
}

func (m *ScanResultsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanResultsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ScanResultsJson) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.ScanResultsJson)))
		i += copy(dAtA[i:], m.ScanResultsJson)
	}
	if len(m.VscanAgentName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.VscanAgentName)))
		i += copy(dAtA[i:], m.VscanAgentName)
	}
	if len(m.DeviceName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgentpb(dAtA, i, uint64(len(m.DeviceName)))
		i += copy(dAtA[i:], m.DeviceName)
	}
	return i, nil
}

func encodeVarintAgentpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SSHGateway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GatewayName)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.GatewayIp)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.GatewayUsername)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.GatewayPassword)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.GatewayPrivateKey)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	return n
}

func (m *UserDeviceCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialsName)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.CredentialsDeviceVendor)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.IosEnablePassword)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	return n
}

func (m *ScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovAgentpb(uint64(l))
		}
	}
	if m.SshGateway != nil {
		l = m.SshGateway.Size()
		n += 1 + l + sovAgentpb(uint64(l))
	}
	if m.UserDeviceCredentials != nil {
		l = m.UserDeviceCredentials.Size()
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.OvalSourceUrl)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	return n
}

func (m *ScanResultsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScanResultsJson)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.VscanAgentName)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovAgentpb(uint64(l))
	}
	return n
}

func sovAgentpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgentpb(x uint64) (n int) {
	return sovAgentpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SSHGateway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSHGateway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSHGateway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgentpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgentpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDeviceCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDeviceCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDeviceCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialsDeviceVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialsDeviceVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosEnablePassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosEnablePassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgentpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgentpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgentpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgentpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &Device{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SshGateway == nil {
				m.SshGateway = &SSHGateway{}
			}
			if err := m.SshGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDeviceCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserDeviceCredentials == nil {
				m.UserDeviceCredentials = &UserDeviceCredentials{}
			}
			if err := m.UserDeviceCredentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OvalSourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OvalSourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgentpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgentpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanResultsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanResultsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanResultsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanResultsJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScanResultsJson = append(m.ScanResultsJson[:0], dAtA[iNdEx:postIndex]...)
			if m.ScanResultsJson == nil {
				m.ScanResultsJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VscanAgentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VscanAgentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgentpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgentpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgentpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgentpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgentpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgentpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAgentpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgentpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgentpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgentpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgentpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/agentpb.proto", fileDescriptor_agentpb_355d40ef13dbfd8b) }

var fileDescriptor_agentpb_355d40ef13dbfd8b = []byte{
	// 572 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0x5b, 0x9a, 0xd2, 0x71, 0xc1, 0xed, 0x86, 0xa8, 0xa1, 0x02, 0x43, 0x73, 0x40, 0x29,
	0x87, 0x80, 0x02, 0x27, 0x6e, 0x6d, 0x41, 0x34, 0x20, 0x21, 0xe4, 0xa8, 0x39, 0x70, 0xc0, 0xda,
	0xc4, 0x4b, 0xea, 0xe0, 0xee, 0x9a, 0x1d, 0x3b, 0x55, 0x7e, 0x00, 0xe2, 0xc2, 0x81, 0x9f, 0xc5,
	0xb1, 0x07, 0x0e, 0x1c, 0x51, 0xf2, 0x47, 0x90, 0x77, 0xd7, 0x1f, 0x8d, 0x7a, 0xcb, 0xbc, 0x79,
	0x99, 0x9d, 0xf7, 0xde, 0xc8, 0xd0, 0x88, 0xa5, 0x48, 0xc4, 0x33, 0x3a, 0x61, 0x3c, 0x89, 0x47,
	0x5d, 0x55, 0x91, 0x4d, 0x53, 0xb6, 0xff, 0x58, 0x00, 0x83, 0xc1, 0xe9, 0x5b, 0x9a, 0xb0, 0x4b,
	0x3a, 0x27, 0x07, 0xb0, 0x3d, 0xd1, 0x3f, 0x7d, 0x4e, 0x2f, 0x58, 0xcb, 0x7a, 0x6c, 0x75, 0xb6,
	0x3c, 0xdb, 0x60, 0x1f, 0xe8, 0x05, 0x23, 0x0f, 0x01, 0x72, 0x4a, 0x18, 0xb7, 0xd6, 0x14, 0x61,
	0xcb, 0x20, 0xfd, 0x98, 0x1c, 0xc2, 0x4e, 0xde, 0x4e, 0x91, 0x49, 0x35, 0x65, 0x5d, 0x91, 0x1c,
	0x83, 0x9f, 0x19, 0xb8, 0x4a, 0x8d, 0x29, 0xe2, 0xa5, 0x90, 0x41, 0xeb, 0xd6, 0x35, 0xea, 0x47,
	0x03, 0x93, 0x2e, 0x34, 0x0a, 0xaa, 0x0c, 0x67, 0x34, 0x61, 0xfe, 0x57, 0x36, 0x6f, 0x6d, 0x28,
	0xf6, 0x6e, 0xce, 0xd6, 0x9d, 0xf7, 0x6c, 0xde, 0xfe, 0xb1, 0x06, 0xcd, 0xec, 0x9d, 0xd7, 0x6c,
	0x16, 0x8e, 0xd9, 0x89, 0x64, 0x01, 0xe3, 0x49, 0x48, 0x23, 0xcc, 0x1e, 0x1d, 0x97, 0x65, 0x55,
	0xa5, 0x53, 0xc1, 0x95, 0xd2, 0x57, 0x70, 0xbf, 0x4a, 0x0d, 0xd4, 0x2c, 0x7f, 0xc6, 0x78, 0x20,
	0xa4, 0x11, 0xbe, 0x57, 0x21, 0xe8, 0xb7, 0x86, 0xaa, 0x4d, 0xf6, 0xe1, 0xf6, 0x8a, 0xfc, 0xa2,
	0xce, 0x7a, 0x2b, 0x7a, 0x8b, 0x3a, 0x13, 0x1a, 0x0a, 0xf4, 0x19, 0xa7, 0xa3, 0x88, 0x95, 0xb6,
	0x18, 0xa1, 0xa1, 0xc0, 0x37, 0xaa, 0x53, 0x18, 0xf3, 0x08, 0xec, 0xaa, 0x21, 0x75, 0xc5, 0x83,
	0xb8, 0x74, 0xe2, 0x14, 0xea, 0x7a, 0xb1, 0x8c, 0x6a, 0x24, 0x54, 0x44, 0x83, 0x86, 0xf2, 0x64,
	0xc3, 0xd8, 0xa7, 0x41, 0x20, 0x19, 0x62, 0x9e, 0x6c, 0x18, 0x1f, 0x69, 0xa0, 0xfd, 0x7d, 0x0d,
	0xec, 0xc1, 0x98, 0x72, 0x8f, 0x7d, 0x4b, 0x19, 0x26, 0xa4, 0x09, 0xf5, 0xa9, 0x18, 0xf9, 0x61,
	0x60, 0x46, 0x6d, 0x4c, 0xc5, 0xa8, 0x1f, 0x90, 0x43, 0xd8, 0xd4, 0x33, 0xb3, 0x11, 0xeb, 0x1d,
	0xbb, 0xe7, 0x74, 0xf3, 0xdb, 0xd3, 0x8b, 0x78, 0x79, 0x9f, 0xbc, 0x04, 0x1b, 0xf1, 0xdc, 0x37,
	0xf1, 0x29, 0x9f, 0xec, 0x5e, 0xa3, 0xa0, 0x97, 0x77, 0xe9, 0x01, 0xe2, 0x79, 0x7e, 0xa3, 0x43,
	0xd8, 0xcb, 0xac, 0xcc, 0xf3, 0xa8, 0x24, 0xa0, 0xdc, 0xb4, 0x7b, 0x6e, 0x31, 0xe1, 0xc6, 0x13,
	0xf0, 0x9a, 0xe9, 0x8d, 0x97, 0xf1, 0x04, 0x1c, 0x31, 0xa3, 0x91, 0x8f, 0x22, 0x95, 0x63, 0xe6,
	0xa7, 0x32, 0x32, 0xb6, 0xdf, 0xc9, 0xe0, 0x81, 0x42, 0xcf, 0x64, 0xd4, 0xfe, 0x69, 0x41, 0x43,
	0xfb, 0x80, 0x69, 0x94, 0xa0, 0xc7, 0x30, 0x16, 0x1c, 0x19, 0x79, 0x0a, 0xbb, 0x38, 0xa6, 0xdc,
	0x97, 0x1a, 0xf7, 0xa7, 0x28, 0xb8, 0xb2, 0x66, 0xdb, 0x73, 0xb0, 0xe4, 0xbf, 0x43, 0xc1, 0x49,
	0x07, 0x76, 0x66, 0x8a, 0xac, 0x36, 0xd5, 0x81, 0x68, 0xc3, 0xef, 0x2a, 0xfc, 0x28, 0x83, 0x55,
	0x28, 0x2b, 0xa9, 0xad, 0xaf, 0xa6, 0xd6, 0xfb, 0x0c, 0xbb, 0xc3, 0xe2, 0x2f, 0x03, 0x26, 0x55,
	0xd6, 0x7d, 0x70, 0x8e, 0xd3, 0x30, 0x0a, 0xb2, 0x3d, 0x4f, 0x04, 0xff, 0x12, 0x4e, 0xc8, 0xbd,
	0xd2, 0xd7, 0x32, 0xc4, 0xfd, 0x07, 0x2b, 0xe8, 0x35, 0x49, 0xed, 0xda, 0x73, 0xeb, 0xf8, 0xe0,
	0xf7, 0xc2, 0xb5, 0xae, 0x16, 0xae, 0xf5, 0x6f, 0xe1, 0x5a, 0xbf, 0x96, 0x6e, 0xed, 0x6a, 0xe9,
	0xd6, 0xfe, 0x2e, 0xdd, 0xda, 0xa7, 0xfc, 0x23, 0x32, 0xaa, 0xab, 0x8f, 0xca, 0x8b, 0xff, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x56, 0x78, 0x20, 0x6c, 0x6b, 0x04, 0x00, 0x00,
}
